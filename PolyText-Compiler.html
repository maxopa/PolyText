<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PolyText Reader</title>
    <style>
        :root {
            --bg-body: #f4f6f8;
            --bg-paper: #ffffff;
            --text-main: #212529;
            --accent: #0d6efd;
            --border: #dee2e6;
            --tooltip-bg: #343a40;
            --trans-bg: #f8fbff;
        }

        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            line-height: 1.6; 
            background: var(--bg-body); 
            color: var(--text-main); 
            margin: 0; 
            padding-bottom: 20px;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- HEADER LAYOUT (Grid for perfect centering) --- */
        .header-bar {
            background: #fff; 
            border-bottom: 1px solid #ccc;
            position: sticky; top: 0; z-index: 1000;
            padding: 8px 20px;
            display: grid;
            grid-template-columns: 1fr auto 1fr; /* –õ—ñ–≤–æ - –¶–µ–Ω—Ç—Ä - –ü—Ä–∞–≤–æ */
            align-items: center;
            gap: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .header-left { justify-self: start; display: flex; gap: 10px; align-items: center; }
        .header-center { justify-self: center; display: flex; gap: 10px; align-items: center; }
        .header-right { justify-self: end; display: flex; gap: 15px; align-items: center; }

        /* Groups */
        .toolbar-group {
            display: flex; align-items: center; gap: 10px;
        }
        .divider {
            width: 1px; height: 20px; background: #e0e0e0; margin: 0 2px;
        }

        /* Inputs */
        .compact-input-group {
            display: flex; align-items: center; gap: 5px;
            font-size: 0.9rem; color: #555;
            background: #f8f9fa;
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        select, input[type="number"] { 
            border: none; background: transparent; 
            font-weight: 600; color: #333; cursor: pointer; 
            outline: none;
        }
        input[type="number"] { width: 40px; text-align: center; }

        /* Translation Section */
        .trans-label { font-weight: 600; font-size: 0.9rem; color: #444; }
        
        #targetLangsBox {
            display: flex; gap: 8px; align-items: center;
        }
        .lang-checkbox-label {
            display: flex; align-items: center; gap: 4px; 
            font-size: 0.85rem; font-weight: 600; 
            cursor: pointer; user-select: none;
            color: #444;
            background: #fff; border: 1px solid #ddd;
            padding: 2px 6px; border-radius: 4px;
        }
        .lang-checkbox-label:hover { border-color: var(--accent); color: var(--accent); }
        .lang-checkbox-label input { margin: 0; }

        /* Buttons */
        .btn {
            background: var(--accent); color: white; border: none; padding: 4px 10px;
            border-radius: 4px; cursor: pointer; font-size: 0.85rem; display: inline-flex; align-items: center;
            text-decoration: none; user-select: none; transition: opacity 0.2s; white-space: nowrap;
        }
        .btn-sm { padding: 2px 8px; font-size: 0.8rem; }
        .btn-outline { background: transparent; border: 1px solid var(--accent); color: var(--accent); }
        .btn:hover { opacity: 0.9; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; background: #ccc; border-color: #ccc; color: #fff; }

        /* --- Content --- */
        #viewer { 
            max-width: 850px; 
            margin: 20px auto; 
            padding: 40px; 
            background: var(--bg-paper); 
            min-height: 50vh; 
            box-shadow: 0 2px 15px rgba(0,0,0,0.04); 
            border-radius: 8px; 
        }

        /* Typography */
        .ptxt-h1 { border-bottom: 2px solid #eee; padding-bottom: 0.5rem; margin-top: 0.5rem; font-size: 2rem; line-height: 1.2; font-weight: 700; color: #222; }
        .ptxt-h2 { margin-top: 1.8rem; font-size: 1.5rem; color: #333; font-weight: 600; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .ptxt-h3 { margin-top: 1.4rem; font-size: 1.25rem; color: #555; font-weight: 600; }
        
        .ptxt-ul, .ptxt-ol { padding-left: 1.5rem; margin-bottom: 1rem; }
        .ptxt-li { margin-bottom: 0.5rem; }
        .ptxt-p { margin-bottom: 1.2rem; text-align: justify; }

        /* Sentence & Interaction */
        .unit-container { display: inline; }
        .sentence-wrapper { display: inline; margin-right: 4px; }

        .word { display: inline; white-space: pre-wrap; }
        .word.has-def {
            cursor: pointer; border-bottom: 1px dotted #999; color: #000;
        }
        .word.has-def:active, .word.has-def.active-tip {
            background: rgba(13, 110, 253, 0.2); color: var(--accent); border-bottom-color: var(--accent);
        }

        /* Translation Panel */
        .trans-panel {
            display: none; width: 100%; margin: 6px 0 12px 0; padding: 8px 12px;
            background: var(--trans-bg); border-left: 3px solid var(--accent);
            border-radius: 4px; font-size: 0.9em; color: #333; text-align: left;
        }
        .trans-panel.show { display: block; animation: fadeIn 0.2s ease-out; }
        @keyframes fadeIn { from {opacity:0; transform:translateY(-5px);} to {opacity:1; transform:translateY(0);} }

        /* Toggle Icon */
        .toggle-icon {
            display: inline-flex; align-items: center; justify-content: center;
            width: 18px; height: 18px; background: #eee; border-radius: 50%;
            font-size: 10px; font-weight: bold; color: #777; cursor: pointer;
            margin-left: 2px; vertical-align: middle; user-select: none;
            transition: all 0.2s; transform: translateY(-2px);
        }
        .toggle-icon:hover, .toggle-icon.active { background: var(--accent); color: #fff; }

        .lang-badge {
            display: inline-block; padding: 1px 4px; border-radius: 3px;
            background: #fff; color: var(--accent); border: 1px solid var(--accent);
            font-size: 0.7em; font-weight: bold; margin-right: 6px; vertical-align: middle; text-transform: uppercase;
        }

        /* Tooltip */
        #tooltip {
            position: fixed; background: var(--tooltip-bg); color: #fff;
            padding: 8px 12px; border-radius: 6px; font-size: 0.9em;
            pointer-events: none; opacity: 0; z-index: 2000;
            max-width: 85vw; width: max-content;
            box-shadow: 0 4px 15px rgba(0,0,0,0.25);
            transition: opacity 0.1s;
        }
        #tooltip.visible { opacity: 1; }

        /* Bottom Pagination */
        .pagination-bottom {
            display: flex; justify-content: center; align-items: center; gap: 15px;
            margin: 20px auto; padding-top: 20px; border-top: 1px solid #eee;
            max-width: 850px;
        }

        /* Helper for exported mode */
        body.is-exported #fileOperations { display: none !important; }

        /* --- RESPONSIVE --- */
        @media (max-width: 900px) {
            .header-bar { 
                display: flex; flex-wrap: wrap; justify-content: space-between; gap: 10px;
            }
            .header-left, .header-center, .header-right { 
                justify-self: auto; flex-grow: 1;
            }
            .header-center { order: 2; width: 100%; justify-content: center; margin-top: 5px; }
            .header-right { justify-content: flex-end; }
            
            #targetLangsBox { overflow-x: auto; max-width: 100%; }
        }
        @media (max-width: 600px) {
             .header-right { flex-wrap: wrap; justify-content: center; }
        }
    </style>
</head>
<body>

<div class="header-bar" id="mainToolbar">
    
    <div class="header-left" id="fileOperations">
        <label class="btn btn-sm">üìÇ –í—ñ–¥–∫—Ä. <input type="file" id="fileInput" hidden accept=".ptxt,.txt"></label>
        <button class="btn btn-sm btn-outline" onclick="downloadBook()">üíæ –ó–±–µ—Ä.</button>
    </div>

    <div class="header-center">
        <button class="btn btn-sm btn-outline" onclick="changePage(-1)" id="btnPrevTop">‚Üê</button>
        <div class="compact-input-group">
            –°—Ç–æ—Ä. <input type="number" id="pageInputTop" min="1" onchange="goToPage(this.value)"> 
            / <span id="totalPagesTop">1</span>
        </div>
        <button class="btn btn-sm btn-outline" onclick="changePage(1)" id="btnNextTop">‚Üí</button>
    </div>

    <div class="header-right">
        
        <div class="compact-input-group" title="–û—Å–Ω–æ–≤–Ω–∞ –º–æ–≤–∞">
            <span>–ú–æ–≤–∞:</span>
            <select id="mainLangSelect" onchange="changeMainLang(this.value)"></select>
        </div>

        <div class="compact-input-group" title="–ö—ñ–ª—å–∫—ñ—Å—Ç—å –±–ª–æ–∫—ñ–≤ –Ω–∞ —Å—Ç–æ—Ä—ñ–Ω—Ü—ñ">
            <span>–ë–ª–æ–∫—ñ–≤:</span>
            <input type="number" id="pageSizeInput" value="15" min="1" max="500" onchange="updatePageSize(this.value)">
        </div>

        <div class="divider"></div>

        <span class="trans-label">–ü–µ—Ä–µ–∫–ª–∞–¥:</span>
        <div id="targetLangsBox">
            </div>

    </div>
</div>

<div id="viewer">
    <div style="text-align:center; margin-top:50px; color:#888;" id="placeholder">
        –ó–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ .ptxt —Ñ–∞–π–ª.<br><br>
        <button class="btn" style="width: auto" onclick="loadExample()">–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –¥–µ–º–æ</button>
    </div>
</div>

<div id="paginationBottom" class="pagination-bottom" style="display: none;">
    <button class="btn btn-outline" onclick="changePage(-1)" id="btnPrevBottom">‚Üê –ù–∞–∑–∞–¥</button>
    <div style="font-size: 0.9rem;">
        –°—Ç–æ—Ä—ñ–Ω–∫–∞ <input type="number" id="pageInputBottom" class="compact-input-group" style="display:inline-block; width:50px; padding:4px;" min="1" onchange="goToPage(this.value)"> 
        –∑ <span id="totalPagesBottom">1</span>
    </div>
    <button class="btn btn-outline" onclick="changePage(1)" id="btnNextBottom">–í–ø–µ—Ä–µ–¥ ‚Üí</button>
</div>

<div id="tooltip"></div>

<script>
    // --- Global State ---
    let appData = { 
        blocks: [], dictionary: {}, langs: [], 
        currentMain: '', currentTargets: [],
        currentPage: 1,
        itemsPerPage: 15
    };

    // --- 1. Parser ---
    function parsePTXT(text) {
        const lines = text.split(/\r?\n/);
        const blocks = [];
        let currentBlock = null;
        const dictRaw = [];
        const foundLangs = new Set();

        const finishBlock = () => {
            if (currentBlock && currentBlock.tag !== 'dict') {
                currentBlock.units = parseUnits(currentBlock.rawLines, foundLangs);
                blocks.push(currentBlock);
            }
        };

        lines.forEach((line) => {
            if (line.startsWith('::')) {
                finishBlock();
                const tag = line.substring(2).trim();
                currentBlock = { tag: tag === 'dict' ? 'dict' : tag, rawLines: [] };
            } else {
                if (currentBlock) {
                    if (currentBlock.tag === 'dict') dictRaw.push(line);
                    else currentBlock.rawLines.push(line);
                }
            }
        });
        finishBlock();

        return { 
            blocks, 
            dictionary: parseDictionary(dictRaw), 
            langs: Array.from(foundLangs) 
        };
    }

    function parseUnits(lines, langSet) {
        let units = [];
        let buffer = [];
        [...lines, ''].forEach(line => {
            if (!line.trim()) {
                if (buffer.length) {
                    const u = {};
                    let hasData = false;
                    buffer.forEach(l => {
                        const m = l.match(/^([a-zA-Z]+):\s+(.*)$/);
                        if (m) { u[m[1]] = m[2]; langSet.add(m[1]); hasData = true; }
                    });
                    if(hasData) units.push(u);
                    buffer = [];
                }
            } else buffer.push(line);
        });
        return units;
    }

    function parseDictionary(lines) {
        const dict = {};
        let group = {};
        [...lines, ''].forEach(line => {
            if (!line.trim()) {
                if (Object.keys(group).length) {
                    Object.values(group).forEach(phrase => {
                        const key = normalize(phrase);
                        if(key) dict[key] = group;
                    });
                    group = {};
                }
            } else {
                const m = line.match(/^([a-zA-Z]+):\s+(.*)$/);
                if (m) group[m[1]] = m[2];
            }
        });
        return dict;
    }

    function normalize(str) {
        const clean = str.replace(/[\*\_\`]/g, '');
        return clean.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"").toLowerCase().trim();
    }

    // --- 2. Logic & UI ---

    function initViewer(data) {
        appData = { ...appData, ...data };
        appData.currentPage = 1; 
        
        if (appData.itemsPerPage) {
            document.getElementById('pageSizeInput').value = appData.itemsPerPage;
        } else {
            appData.itemsPerPage = 15;
        }

        const mainSel = document.getElementById('mainLangSelect');
        mainSel.innerHTML = '';
        appData.langs.forEach(lang => {
            const opt = document.createElement('option');
            opt.value = lang;
            opt.innerText = lang.toUpperCase();
            if (lang === appData.currentMain) opt.selected = true;
            mainSel.appendChild(opt);
        });

        renderTargetControls();
        renderPage();
    }

    function renderTargetControls() {
        const box = document.getElementById('targetLangsBox');
        box.innerHTML = '';
        
        appData.langs.forEach(lang => {
            if (lang === appData.currentMain) return;
            
            const label = document.createElement('label');
            label.className = 'lang-checkbox-label';
            
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.value = lang;
            cb.checked = appData.currentTargets.includes(lang);
            cb.onchange = updateTargets;
            
            const txt = document.createElement('span');
            txt.innerText = lang.toUpperCase();

            label.appendChild(cb);
            label.appendChild(txt);
            box.appendChild(label);
        });
    }

    function updateTargets() {
        appData.currentTargets = Array.from(document.querySelectorAll('#targetLangsBox input:checked')).map(i => i.value);
        document.querySelectorAll('.trans-panel.show').forEach(el => el.classList.remove('show'));
        document.querySelectorAll('.toggle-icon.active').forEach(el => el.classList.remove('active'));
    }

    window.changeMainLang = function(val) {
        appData.currentMain = val;
        appData.currentTargets = appData.currentTargets.filter(l => l !== val);
        renderTargetControls();
        renderPage();
    }

    window.updatePageSize = function(val) {
        let size = parseInt(val);
        if(!size || size < 1) size = 15;
        appData.itemsPerPage = size;
        appData.currentPage = 1; 
        renderPage();
    }

    // --- PAGINATION ---
    window.changePage = function(delta) {
        const maxPages = Math.ceil(appData.blocks.length / appData.itemsPerPage);
        let newPage = appData.currentPage + delta;
        if (newPage < 1) newPage = 1;
        if (newPage > maxPages) newPage = maxPages;
        
        if (newPage !== appData.currentPage) {
            appData.currentPage = newPage;
            renderPage();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    }

    window.goToPage = function(val) {
        const maxPages = Math.ceil(appData.blocks.length / appData.itemsPerPage);
        let pg = parseInt(val);
        if (!pg) return;
        if (pg < 1) pg = 1;
        if (pg > maxPages) pg = maxPages;
        appData.currentPage = pg;
        renderPage();
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    function updatePaginationUI() {
        const total = Math.ceil(appData.blocks.length / appData.itemsPerPage);
        const hasPages = total > 1;

        // Show/Hide bottom paging
        document.getElementById('paginationBottom').style.display = hasPages ? 'flex' : 'none';
        
        // Update Values Top & Bottom
        ['Top', 'Bottom'].forEach(suffix => {
            const input = document.getElementById('pageInput' + suffix);
            const totalSpan = document.getElementById('totalPages' + suffix);
            const prevBtn = document.getElementById('btnPrev' + suffix);
            const nextBtn = document.getElementById('btnNext' + suffix);

            if(input) input.value = appData.currentPage;
            if(totalSpan) totalSpan.innerText = total;
            if(prevBtn) prevBtn.disabled = appData.currentPage === 1;
            if(nextBtn) nextBtn.disabled = appData.currentPage === total;
        });
    }

    function renderPage() {
        const v = document.getElementById('viewer');
        v.innerHTML = '';
        if(!appData.blocks.length) return;

        const startIdx = (appData.currentPage - 1) * appData.itemsPerPage;
        const endIdx = startIdx + appData.itemsPerPage;
        const pageBlocks = appData.blocks.slice(startIdx, endIdx);

        pageBlocks.forEach((blk, localIdx) => {
            const globalIdx = startIdx + localIdx;
            
            const tagMap = { 'h1':'h1','h2':'h2','h3':'h3','p':'div','ul':'ul','ol':'ol' };
            const el = document.createElement(tagMap[blk.tag] || 'div');
            
            if(blk.tag.startsWith('h')) el.className = `ptxt-${blk.tag}`;
            else if(blk.tag === 'p') el.className = 'ptxt-p';
            else if(blk.tag === 'ul' || blk.tag === 'ol') el.className = `ptxt-${blk.tag}`;

            blk.units.forEach((unit, uIdx) => {
                const uid = `u-${globalIdx}-${uIdx}`;
                const text = unit[appData.currentMain] || '';
                const htmlText = tokenize(text);
                
                let itemTag = 'div'; 
                if (['ul','ol'].includes(blk.tag)) itemTag = 'li';
                
                const unitWrapper = document.createElement(itemTag);
                if (['ul','ol'].includes(blk.tag)) unitWrapper.className = 'ptxt-li';
                else unitWrapper.className = 'unit-container';

                unitWrapper.innerHTML = `
                    <div class="sentence-wrapper">
                        ${htmlText}<span class="toggle-icon" onclick="toggleLine(event, '${uid}', this)">t</span>
                    </div>
                    <div id="${uid}" class="trans-panel"></div>
                `;
                
                unitWrapper.querySelector('.trans-panel').dataset.unit = JSON.stringify(unit);
                el.appendChild(unitWrapper);
            });
            v.appendChild(el);
        });

        updatePaginationUI();
    }

    // --- Helpers ---
    function renderMarkdown(text) {
        return text
            .replace(/\*\*(.*?)\*\*/g, '<b>$1</b>')
            .replace(/__(.*?)__/g, '<u>$1</u>')
            .replace(/`(.*?)`/g, '<code style="background:#eee;padding:0 2px">$1</code>');
    }

    function stripMarkdown(text) {
        return text.replace(/\*\*(.*?)\*\*/g, '$1').replace(/__(.*?)__/g, '$1').replace(/`(.*?)`/g, '$1');
    }

    function tokenize(text) {
        const htmlWithTags = renderMarkdown(text);
        const div = document.createElement('div');
        div.innerHTML = htmlWithTags;

        function walk(node) {
            if (node.nodeType === 3) {
                const parts = node.nodeValue.split(/(\s+|[.,!?;:()]+)/g);
                const spans = parts.map(part => {
                    if(!part.trim()) return part;
                    const key = normalize(part);
                    if(appData.dictionary[key]) {
                        return `<span class="word has-def" onclick="toggleTip(event, '${part}')">${part}</span>`;
                    }
                    return `<span class="word">${part}</span>`;
                });
                const wrapper = document.createElement('span');
                wrapper.innerHTML = spans.join('');
                node.parentNode.replaceChild(wrapper, node);
            } else if (node.nodeType === 1) {
                Array.from(node.childNodes).forEach(walk);
            }
        }
        walk(div);
        return div.innerHTML;
    }

    // --- Interactions ---
    window.toggleLine = function(e, id, btn) {
        e.stopPropagation();
        const panel = document.getElementById(id);
        const unit = JSON.parse(panel.dataset.unit);

        if(panel.classList.contains('show')) {
            panel.classList.remove('show');
            btn.classList.remove('active');
        } else {
            let html = '';
            if(!appData.currentTargets.length) {
                html = '<em style="color:#777">–û–±–µ—Ä—ñ—Ç—å –º–æ–≤–∏ –ø–µ—Ä–µ–∫–ª–∞–¥—É</em>';
            } else {
                appData.currentTargets.forEach(lang => {
                    if(unit[lang]) {
                        const cleanText = stripMarkdown(unit[lang]);
                        html += `<div style="margin-bottom:4px"><span class="lang-badge">${lang}</span>${cleanText}</div>`;
                    }
                });
            }
            if(!html) html = '<em style="color:#777">–ù–µ–º–∞—î –ø–µ—Ä–µ–∫–ª–∞–¥—É</em>';
            
            panel.innerHTML = html;
            panel.classList.add('show');
            btn.classList.add('active');
        }
    }

    const tip = document.getElementById('tooltip');
    let activeWord = null;

    window.toggleTip = function(e, word) {
        e.stopPropagation();
        if (activeWord === word && tip.classList.contains('visible')) {
            hideTip();
            return;
        }

        const key = normalize(word);
        const def = appData.dictionary[key];
        if(!def) return;

        let html = `<strong>${word}</strong>`;
        let hasContent = false;
        const targetLangs = appData.currentTargets.length > 0 ? appData.currentTargets : Object.keys(def).filter(k => k !== appData.currentMain);

        targetLangs.forEach(lang => {
            if(def[lang]) {
                html += `<div style="margin-top:4px"><span style="color:#ccc; font-size:0.8em; margin-right:5px">[${lang.toUpperCase()}]</span>${def[lang]}</div>`;
                hasContent = true;
            }
        });

        if(!hasContent) html += '<div style="margin-top:4px; font-style:italic; font-size:0.8em">–û–±–µ—Ä—ñ—Ç—å –º–æ–≤–∏</div>';

        tip.innerHTML = html;
        tip.classList.add('visible');
        activeWord = word;

        const r = e.target.getBoundingClientRect();
        const tr = tip.getBoundingClientRect();
        
        let top = r.top - tr.height - 10;
        let left = r.left + (r.width/2) - (tr.width/2);

        if(top < 10) top = r.bottom + 10;
        if(left < 10) left = 10;
        if(left + tr.width > window.innerWidth) left = window.innerWidth - tr.width - 10;

        tip.style.top = top + 'px';
        tip.style.left = left + 'px';
        
        document.querySelectorAll('.word.active-tip').forEach(el => el.classList.remove('active-tip'));
        e.target.classList.add('active-tip');
    }

    function hideTip() {
        tip.classList.remove('visible');
        activeWord = null;
        document.querySelectorAll('.word.active-tip').forEach(el => el.classList.remove('active-tip'));
    }

    document.addEventListener('click', () => hideTip());

    // --- IO Logic ---
    document.getElementById('fileInput').addEventListener('change', e => {
        const f = e.target.files[0];
        if(!f) return;
        const r = new FileReader();
        r.onload = (evt) => {
            const res = parsePTXT(evt.target.result);
            const main = res.langs[0] || 'en';
            initViewer({
                blocks: res.blocks,
                dictionary: res.dictionary,
                langs: res.langs,
                currentMain: main,
                currentTargets: res.langs.filter(l => l !== main)
            });
        };
        r.readAsText(f);
    });

    window.loadExample = function() {
        const text = `
::h1
en: Demo File
uk: –î–µ–º–æ —Ñ–∞–π–ª

::p
en: This is a **smart** book. Each sentence is one unit. They should flow like a paragraph.
uk: –¶–µ **—Ä–æ–∑—É–º–Ω–∞** –∫–Ω–∏–≥–∞. –ö–æ–∂–Ω–µ —Ä–µ—á–µ–Ω–Ω—è ‚Äî —Ü–µ –æ–¥–∏–Ω —é–Ω—ñ—Ç. –í–æ–Ω–∏ –º–∞—é—Ç—å –π—Ç–∏ —è–∫ –∞–±–∑–∞—Ü.

en: If you click the icon, the translation appears below. It pushes the next line down.
uk: –Ø–∫—â–æ –Ω–∞—Ç–∏—Å–Ω—É—Ç–∏ —ñ–∫–æ–Ω–∫—É, –ø–µ—Ä–µ–∫–ª–∞–¥ –∑'—è–≤–∏—Ç—å—Å—è –∑–Ω–∏–∑—É. –í—ñ–Ω –∑—Å—É–≤–∞—î –Ω–∞—Å—Ç—É–ø–Ω–∏–π —Ä—è–¥–æ–∫ –≤–Ω–∏–∑.

::h2
en: Chapter 2
uk: –†–æ–∑–¥—ñ–ª 2

::p
en: Here is another paragraph to test pagination. We need enough blocks to fill a page.
uk: –û—Å—å —â–µ –æ–¥–∏–Ω –∞–±–∑–∞—Ü –¥–ª—è —Ç–µ—Å—Ç—É –ø–∞–≥—ñ–Ω–∞—Ü—ñ—ó. –ù–∞–º –ø–æ—Ç—Ä—ñ–±–Ω–æ –¥–æ—Å—Ç–∞—Ç–Ω—å–æ –±–ª–æ–∫—ñ–≤, —â–æ–± –∑–∞–ø–æ–≤–Ω–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É.

en: Block 3.
uk: –ë–ª–æ–∫ 3.

en: Block 4.
uk: –ë–ª–æ–∫ 4.

en: Block 5.
uk: –ë–ª–æ–∫ 5.

::dict
en: smart
uk: —Ä–æ–∑—É–º–Ω–∞
`.trim();
        const res = parsePTXT(text);
        initViewer({
            blocks: res.blocks,
            dictionary: res.dictionary,
            langs: res.langs,
            currentMain: 'en',
            currentTargets: ['uk']
        });
    }

    window.downloadBook = function() {
        if(!appData.blocks.length) { alert('–°–ø–æ—á–∞—Ç–∫—É –≤—ñ–¥–∫—Ä–∏–π—Ç–µ —Ñ–∞–π–ª'); return; }
        
        const html = document.documentElement.outerHTML;
        const scriptStart = '<sc' + 'ript>';
        const scriptEnd = '</sc' + 'ript>';
        
        const injectScript = `
        ${scriptStart}
            window.EXPORTED_DATA = ${JSON.stringify(appData)};
            
            window.addEventListener('DOMContentLoaded', function() {
                document.body.classList.add('is-exported');
                if(window.EXPORTED_DATA) {
                    initViewer(window.EXPORTED_DATA);
                }
            });
        ${scriptEnd}
        `;
        
        const closeTag = '</body>';
        const lastIndex = html.lastIndexOf(closeTag);
        
        if (lastIndex !== -1) {
             const finalHtml = html.substring(0, lastIndex) + injectScript + html.substring(lastIndex);
             const blob = new Blob([finalHtml], {type: 'text/html'});
             const url = URL.createObjectURL(blob);
             const a = document.createElement('a');
             a.href = url;
             a.download = 'polytext_book.html';
             document.body.appendChild(a);
             a.click();
             document.body.removeChild(a);
             URL.revokeObjectURL(url);
        }
    }

    if(window.EXPORTED_DATA) {
        // Init happens via event listener injected during export
    }
</script>
</body>
</html>